#!/usr/bin/env cs
#
# Covariant Script Package Manager v2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2021 Michael Lee(李登淳)
#
# Email:   lee@covariant.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn
#
# Config File Structural
#
# ~/.cspkg
#   cspkg.log
#   config.json
#   packages.json
#

import codec.json as json
import process
import regex
import curl

namespace utils
    function open_json(path)
        var ifs = iostream.ifstream(path)
        return json.to_var(json.from_stream(ifs))
    end
    function save_json(val, path)
        var ofs = iostream.ofstream(path)
        ofs.print(json.to_string(json.from_var(val)))
    end
    function filter(str, cond)
        var _s = ""
        foreach ch in str
            if cond(ch)
                _s += ch
            end
        end
        return move(_s)
    end
    function http_get(url)
        var buff = new iostream.char_buff
        var session = curl.make_session_os(buff.get_ostream())
        session.set_url(url)
        if config.content.exist("proxy")
            session.set_proxy(config.content.proxy)
        end
        session.set_ssl_verify_host(false)
        session.set_ssl_verify_peer(false)
        session.set_connect_timeout_ms(config.content.timeout_ms.to_number())
        session.set_accept_timeout_ms(config.content.timeout_ms.to_number())
        session.set_transmit_timeout_ms(config.content.timeout_ms.to_number())
        if session.perform()
            return buff.get_string()
        else
            return null
        end
    end
    function http_get_file(url, path)
        var ofs = iostream.fstream(path, iostream.openmode.bin_out)
        if !ofs.good()
            return false
        end
        var session = curl.make_session_os(ofs)
        session.set_url(url)
        if config.content.exist("proxy")
            session.set_proxy(config.content.proxy)
        end
        session.set_ssl_verify_host(false)
        session.set_ssl_verify_peer(false)
        session.set_connect_timeout_ms(config.content.timeout_ms.to_number())
        session.set_accept_timeout_ms(config.content.timeout_ms.to_number())
        session.set_transmit_timeout_ms(config.content.timeout_ms.to_number())
        return session.perform()
    end
end

namespace env
    function user_home()
        if system.is_platform_windows()
            return system.getenv("USERPROFILE")
        else
            return system.getenv("HOME")
        end
    end
    function covscript_home()
        try
            return system.getenv("COVSCRIPT_HOME")
        catch e; end
        if system.is_platform_windows()
            return env.user_home() + system.path.separator + "Documents" + system.path.separator + "CovScript"
        end
        if system.is_platform_linux()
            return "/usr/share/covscript"
        end
        if system.is_platform_macos()
            return "/Applications/CovScript.app/Contents/MacOS/covscript"
        end
    end
    function platform()
        if system.is_platform_windows()
            return "windows"
        end
        if system.is_platform_linux()
            return "linux"
        end
        if system.is_platform_macos()
            return "macos"
        end
    end
    function arch()
        if system.is_platform_unix()
            var p = process.exec("arch", {})
            return p.out().getline()
        else
            var p = process.exec("wmic", {"OS", "GET", "OSArchitecture"}); p.out().getline()
            var name = utils.filter(p.out().getline(), [](ch)->!ch.isspace())
            switch name
                default
                    throw runtime.exception("Unrecognizable platform name: " + name)
                end
                case "64-bit"
                    return "x86_64"
                end
                case "32-bit"
                    return "i386"
                end
            end
        end
    end
end

namespace config
    constant version = "2.0"
    @begin
    var default_content = {
        "arch" : env.arch(),
        "home" : env.covscript_home(),
        "timeout_ms" : "1000",
        # "proxy" : ""
        "source" : "https://raw.githubusercontent.com/covscript/cspkg-sources/main/index.json"
    }.to_hash_map()
    @end
    var content = null
    function compose_home()
        return env.user_home() + system.path.separator + ".cspkg"
    end
    function compose_log()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "cspkg.log"
    end
    function compose_config()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "config.json"
    end
    function compose_packages()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "packages.json"
    end
    function save()
        utils.save_json(config.content, config.compose_config())
    end
    function create()
        system.file.mkdir(config.compose_home())
        if !system.file.exists(config.compose_config())
            config.save()
        end
    end
    function init()
        if !system.file.exists(config.compose_config())
            config.content = config.default_content
            config.create()
        else
            config.content = utils.open_json(config.compose_config())
        end
    end
end

namespace log_impl
    var log = null
    function open_log()
        if log_impl.log == null
            system.file.mkdir(config.compose_home())
            log_impl.log = iostream.fstream(config.compose_log(), iostream.openmode.app)
        end
    end
end

function cspkg_log(msg)
    log_impl.open_log()
    system.out.println(msg)
    log_impl.log.println(msg)
end

class graph
    var edge = new array, indegree = new hash_map, outdegree = new hash_map, master = new hash_set
    var vis = new hash_map

    function initialize()
        edge[0] = new hash_map
        edge[1] = new hash_map
    end

    function add_edge(pac, dep) # pac -> dep
        if !edge[0].exist(pac)
            edge[0][pac] = new hash_set
        end
        if !edge[1].exist(dep)
            edge[1][dep] = new hash_set
        end
        
        edge[0][pac].insert(dep)
        edge[1][dep].insert(pac)

        if !outdegree.exist(pac)
            outdegree[pac] = 0
        end
        if !indegree.exist(dep)
            indegree[dep] = 0
        end
        outdegree[pac]++
        indegree[dep]++
    end

    function del_node(node)
        if !edge[0].exist(node)
            return
        end
        foreach x in edge[0][node]
            indegree[x]--
            edge[1][x].erase(node)
        end
        edge[0][node].clear()
        outdegree[node] = 0
        if master.exist(node)
            master.erase(node)
        end
    end

    function dfs(node, flag)
        var res = new hash_set
        if vis.exist(node) && vis[node] == true
            return res
        end
        vis[node] = true
        res.insert(node)
        if edge[to_integer(flag)].exist(node)
            foreach x in edge[to_integer(flag)].at(node)
                res = hash_set.merge(res, dfs(x, flag))
            end
        end
        return res
    end

    function get_dependencies(nodes)
        vis.clear()
        if typeid nodes == typeid array
            var res = new hash_set
            foreach x in nodes do hash_set.merge(res, dfs(x, false))
            return res
        end
        if typeid nodes == typeid hash_set
            var res = new hash_set
            foreach x in nodes do hash_set.merge(res, dfs(x, false))
            return res
        end
        return dfs(nodes, false)
    end

    function get_supports(nodes)
        vis.clear()
        if typeid nodes == typeid array
            var res = new hash_set
            foreach x in nodes do hash_set.merge(res, dfs(x, false))
            return res
        end

        if typeid nodes == typeid hash_set
            var res = new hash_set
            foreach x in nodes do hash_set.merge(res, dfs(x, false))
            return res
        end
        return dfs(nodes, false)
    end

    function get_useless()
        var res = new hash_set
        foreach x in outdegree
            if x.second == 0 && !master.exist(x.first) # not master
                res.insert(x.first)
            end
        end
        return res
    end

    function set_master(pac_name)
        master.insert(pac_name)
    end
end

# Command Line Parser

function draw_separator()
    for i = 1, i <= system.console.terminal_width(), ++i
        system.out.print("-")
    end
    system.out.println("")
end

class cspkg_install
    var package_list = new hash_map
    var package_info = new hash_map
    function fetch_source()
        var source = utils.http_get(config.content.source)
        if source == null || source.empty()
            cspkg_log("cspkg: timeout when fetching source.\n")
            system.exit(0)
        end
        source = json.to_var(json.from_string(source))
        if source.exist("universal")
            var url = source.base_url + source.universal
            var uni_source = utils.http_get(url)
            if uni_source != null && !uni_source.empty()
                uni_source = json.to_var(json.from_string(uni_source))
                foreach it in uni_source do package_list.insert(it.first, it.second)
            else
                cspkg_log("cspkg: timeout when fetching universal source.\n")
            end
        end
        if source.exist(env.platform())
            if source[env.platform()].exist(config.content.arch)
                var url = source.base_url + source[env.platform()][config.content.arch]
                var os_source = utils.http_get(url)
                if os_source != null && !os_source.empty()
                    os_source = json.to_var(json.from_string(os_source))
                    foreach it in os_source
                        if package_list.exist(it.first)
                            cspkg_log("cspkg: package index \'" + it.first + "\' existing, skipping...\n")
                        else
                            package_list.insert(it.first, it.second)
                        end
                    end
                else
                    cspkg_log("cspkg: timeout when fetching platform source.\n")
                end
            else
                cspkg_log("cspkg: target source does not support current arch \'" + config.content.arch + "\'.\n")
            end
        else
            cspkg_log("cspkg: target source does not support current OS \'" + env.platform() + "\'.\n")
        end
    end
    function run(opt, args)
        config.init()
        fetch_source()
        if !opt.empty()
            switch opt[0]
                default
                    cspkg_log("cspkg: unknown option for install: \'" + opt[0] + "\'.\n")
                    system.exit(0)
                end
                case "--import"
                    if opt.size != 1
                        cspkg_log("cspkg: wrong arguments for install --import command.\n")
                        system.exit(0)
                    end
                    var p = system.path.scan(env.covscript_home() + system.path.separator + "imports")
                    var reg = regex.build("^(.*)\\.(cse|csp)$")
                    foreach it in p
                        if it.type == system.path.type.reg
                            var name = it.name
                            var r = reg.match(name)
                            if !r.empty()
                                name = r.str(1)
                                if package_list.exist(name)
                                    var info = utils.http_get(package_list.at(name))
                                    if info == null || info.empty()
                                        cspkg_log("cspkg: timeout when fetching package information: \'" + it.name + "\'.\n")
                                    else
                                        info = json.to_var(json.from_string(info))
                                        package_info.insert(name, info)
                                        cspkg_log("cspkg: found " + info.Info + "(" + info.Version + ")\n")
                                    end
                                else
                                    cspkg_log("cspkg: can not find corresponding package information: \'" + it.name + "\'.\n")
                                end
                            end
                        end
                    end
                    utils.save_json(package_info, config.compose_packages())
                end
            end
        else

        end
    end
end

function run_install(opt, args)
    (new cspkg_install).run(opt, args)
end

class cspkg_config
    function run(opt, args)
        if args.size != 1
            cspkg_log("cspkg: wrong arguments for config command.\n")
            system.exit(0)
        end
        config.init()
        if !config.content.exist(args[0])
            cspkg_log("cspkg: key \'" + args[0] + "\' does not exists.\n")
            system.exit(0)
        end
        if !opt.empty()
            switch opt[0]
                default
                    cspkg_log("cspkg: unknown option for config: \'" + opt[0] + "\'.\n")
                    system.exit(0)
                end
                case "--set"
                    if opt.size != 2
                        cspkg_log("cspkg: wrong arguments for config --set command.\n")
                        system.exit(0)
                    end
                    config.content[args[0]] = opt[1]
                    config.save()
                end
                case "--unset"
                    if opt.size != 1
                        cspkg_log("cspkg: wrong arguments for config --unset command.\n")
                        system.exit(0)
                    end
                    config.content[args[0]] = config.default_content[args[0]]
                    config.save()
                end
            end
        end
        system.out.println(args[0] + " = " + config.content[args[0]])
    end
end

function run_config(opt, args)
    (new cspkg_config).run(opt, args)
end

function list_packages(opt, args)
    if system.file.exists(config.compose_packages())
        var packages = utils.open_json(config.compose_packages())
        system.out.println("Installed Packages")
        draw_separator()
        var max_size_c0 = 0
        foreach it in packages
            if it.first.size > max_size_c0
                max_size_c0 = it.first.size
            end
        end
        system.out.print("Name")
        foreach i in range(max_size_c0) do system.out.print(" ")
        var max_size_c1 = 0
        foreach it in packages
            if it.second.Version.size > max_size_c1
                max_size_c1 = it.second.Version.size
            end
        end
        system.out.print("Version")
        if max_size_c1 < 7
            max_size_c1 = 11
        end
        foreach i in range(max_size_c1 - 7) do system.out.print(" ")
        system.out.println("Description")
        draw_separator()
        foreach it in packages
            system.out.print(it.first)
            foreach i in range(max_size_c0 - it.first.size) do system.out.print(" ")
            system.out.print("    ")
            system.out.print(it.second.Version)
            foreach i in range(max_size_c0 - it.second.Version.size - 7) do system.out.print(" ")
            system.out.print("    ")
            system.out.println(it.second.Info)
        end
    else
        cspkg_log("cspkg: can not find package information. try \'cspkg install --import\'\n")
    end
end

function show_help(opt, args)
@begin
    system.out.println(
        "Usage: cspkg <commands> ... [options] ...\n" +
        "\nCommands:\n" +
        "    install   | -i  <Package>...  Install packages from remote source\n" +
        "    remove    | -r  <Package>...  Remove packages\n" +
        "    config    | -c  <Key>         Manage local configuration\n" +
        "    upgrade   | -u                Upgrade local packages\n" +
        "    clean     | -x                Automatically remove useless packages\n" +
        "    list      | -l                List current packages\n" +
        "    help      | -h                Show help information\n" +
        "    version   | -v                Show version information\n" +
        "\nOptions:\n" +
        "    --import                      scanning local CovScript packages\n" +
        "    --set     <Value>             Set a configuration key\n" +
        "    --unset                       Restore a configuration key to default\n"
    )
@end
end

function show_version(opt, args)
@begin
    system.out.println(
        "Covariant Script Package Manager " + config.version + "\n" +
        "\nEnvironment Variables:\n" +
        "            OS: " + env.platform() + "\n" +
        "          ARCH: " + env.arch() + "\n" +
        "     USER_HOME: " + env.user_home() + "\n" +
        "COVSCRIPT_HOME: " + env.covscript_home() + "\n"
    )
@end
end

function command_error(cmd)
    cspkg_log("cspkg: \'" + cmd + "\' is not a cspkg command. see \'csman help\'\n")
end

var cmd_args = context.cmd_args

if cmd_args.size == 1
    show_help(null, null)
    system.exit(0)
end

@begin
var cspkg_cmds = {
    "install" : run_install,
    "-i" : run_install,
    "config" : run_config,
    "-c" : run_config,
    "list" : list_packages,
    "-l" : list_packages,
    "help" : show_help,
    "-h" : show_help,
    "version" : show_version,
    "-v" : show_version
}.to_hash_map()
@end

var cspkg_options = {}
var cspkg_args = {}

# Processing CLI Args

var target_function = cspkg_cmds[cmd_args[1]]

if target_function == 0
    command_error(cmd_args[1])
    system.exit(0)
end

block
    var idx = 2
    while idx != cmd_args.size
        if cmd_args[idx].find("--", 0) != 0
            cspkg_args.push_back(cmd_args[idx])
        else
            break
        end
        ++idx
    end
    while idx != cmd_args.size
        cspkg_options.push_back(cmd_args[idx])
        ++idx
    end
end

target_function(cspkg_options, cspkg_args)
