#!/usr/bin/env cs
#
# Covariant Script Package Manager Launcher v1.1.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2025 Michael Lee(李登淳)
#
# Email:   mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn
#
# Config File Structural
#
# ~/.cspkg
#   cspkg.log
#   config.json
#   packages.json
#

@require: 210505

import codec.json as json
import process
import regex
import curl

namespace utils
    function open_json(path)
        try
            var ifs = iostream.ifstream(path)
            return json.to_var(json.from_stream(ifs))
        catch e
            return new hash_map
        end
    end
    function save_json(val, path)
        var ofs = iostream.ofstream(path)
        ofs.print(json.to_string(json.from_var(val)))
    end
    function parse_json(source_json, default_val)
        try
            return json.to_var(json.from_string(source_json))
        catch e
            return clone(default_val)
        end
    end
    function process_url(url)
        if url[-1] != '/'
            return url + '/'
        else
            return url
        end
    end
    var win_absolute_path_reg = regex.build("^\\\\*([a-zA-z]:\\\\[^\\s]*)$")
    function process_path(path)
        if path == null or path.size == 0
            return path
        end
        var real_path = '/', fake_path = '\\'
        if system.path.separator == '\\'
            swap(real_path, fake_path)
        end
        var new_path = new string
        var last_path = false
        foreach ch in path
            if ch == fake_path
                ch = real_path
            end
            if ch == real_path
                if last_path
                    continue
                else
                    last_path = true
                end
            else
                last_path = false
            end
            new_path += ch
        end
        if system.path.separator == '\\'
            var m = utils.win_absolute_path_reg.match(new_path)
            if !m.empty()
                new_path = m.str(1)
            end
        end
        if path[0] == real_path
            new_path = to_string(real_path) + new_path
        end
        return new_path
    end
    var url_reg = regex.build("^([a-zA-z]+)://(/*[\\w.:]+)([^\\s]*)$")
    function parse_url(url)
        var m = utils.url_reg.match(url)
        if !m.empty() && m.size() == 4
            if m.str(1) == "file"
                return {"protocol": m.str(1), "hostname": "localhost", "path": utils.process_path(m.str(2) + m.str(3))}.to_hash_map()
            else
                return {"protocol": m.str(1), "hostname": m.str(2), "path": m.str(3)}.to_hash_map()
            end
        else
            return null
        end
    end
    constant low_speed_limit = 100
    function http_get(url)
        var url_info = utils.parse_url(url)
        if url_info == null || url_info.protocol != "http" || url_info.protocol != "https"
            cspkg_log("cspkg: error when parsing URL \'" + url + "\".")
            return null
        end
        var buff = new iostream.char_buff
        var session = curl.make_session_os(buff.get_ostream())
        session.set_url(url)
        session.allow_redirect(true)
        if config.content.exist("proxy")
            session.set_proxy(config.content.proxy)
        end
        session.set_ssl_verify_host(false)
        session.set_ssl_verify_peer(false)
        session.set_connect_timeout_ms(config.content.timeout_ms.to_number())
        session.set_accept_timeout_ms(config.content.timeout_ms.to_number())
        session.set_low_speed_limit(low_speed_limit)
        session.set_low_speed_time(config.content.timeout_ms.to_number())
        if session.perform()
            return buff.get_string()
        else
            return null
        end
    end
    function http_get_file(url, path)
        var url_info = utils.parse_url(url)
        if url_info == null || url_info.protocol != "http" || url_info.protocol != "https"
            cspkg_log("cspkg: error when parsing URL \'" + url + "\".")
            return -2
        end
        var ofs = iostream.fstream(path, iostream.openmode.bin_out)
        if !ofs.good()
            return -1
        end
        var session = curl.make_session_os(ofs)
        session.set_url(url)
        session.allow_redirect(true)
        if config.content.exist("proxy")
            session.set_proxy(config.content.proxy)
        end
        session.set_ssl_verify_host(false)
        session.set_ssl_verify_peer(false)
        session.set_connect_timeout_ms(config.content.timeout_ms.to_number())
        session.set_accept_timeout_ms(config.content.timeout_ms.to_number())
        session.set_low_speed_limit(low_speed_limit)
        session.set_low_speed_time(config.content.timeout_ms.to_number())
        return session.perform() ? 1 : 0
    end
    function get_content(url)
        var url_info = utils.parse_url(url)
        if url_info == null
            cspkg_log("cspkg: error when parsing URL \'" + url + "\".")
            return null
        end
        switch url_info.protocol
            case "http"
                return utils.http_get(url)
            end
            case "https"
                return utils.http_get(url)
            end
            case "file"
                var in = iostream.fstream(url_info.path, iostream.openmode.in)
                if !in.good()
                    return null
                end
                var buff = new string
                loop
                    var ch = in.get()
                    if in.eof()
                        break
                    else
                        buff += ch
                    end
                end
                return buff
            end
        end
        cspkg_log("cspkg: unsupported protocol for URL \'" + url + "\".")
        return null
    end
    function get_file(url, path)
        var url_info = utils.parse_url(url)
        if url_info == null
            cspkg_log("cspkg: error when parsing URL \'" + url + "\".")
            return -2
        end
        switch url_info.protocol
            case "http"
                return utils.http_get_file(url, path)
            end
            case "https"
                return utils.http_get_file(url, path)
            end
            case "file"
                return system.file.copy(url_info.path, path) ? 1 : 0
            end
        end
        cspkg_log("cspkg: unsupported protocol for URL \'" + url + "\".")
        return -2
    end
end

namespace env
    var win_ucrt = true
    function user_home()
        if system.is_platform_windows()
            return system.getenv("USERPROFILE")
        else
            return system.getenv("HOME")
        end
    end
    function covscript_home()
        try
            return system.getenv("COVSCRIPT_HOME")
        catch e; end
        if system.is_platform_windows()
            return env.user_home() + system.path.separator + "Documents" + system.path.separator + "CovScript"
        end
        if system.is_platform_linux()
            return "/usr/share/covscript"
        end
        if system.is_platform_darwin()
            return "/Applications/CovScript.app/Contents/MacOS/covscript"
        end
    end
    function platform()
        if system.is_platform_windows()
            if env.win_ucrt
                return "winucrt"
            else
                return "windows"
            end
        end
        if system.is_platform_linux()
            return "linux"
        end
        if system.is_platform_darwin()
            return "macos"
        end
    end
    @begin
    var arch_map = {
        "AMD64" : "x86_64",
        "ARM64" : "arm64",
        "x86"   : "i386"
    }.to_hash_map()
    @end
    function arch()
        if system.is_platform_unix()
            var p = process.exec("arch", {})
            return p.out().getline()
        else
            var arch_name = system.getenv("PROCESSOR_ARCHITECTURE")
            if env.arch_map.exist(arch_name)
                return env.arch_map[arch_name]
            else
                throw runtime.exception("Unrecognizable platform name: " + arch_name)
            end
        end
    end
end

namespace config
    @begin
    var default_content = {
        "arch" : env.arch(),
        "home" : env.covscript_home(),
        "timeout_ms" : "3000",
    #   "proxy" : ""
        "source" : "http://mirrors.covariant.cn/cspkg/"
    }.to_hash_map()
    @end
    var content = null
    var cancel_prompt = false
    function compose_home()
        return env.user_home() + system.path.separator + ".cspkg"
    end
    function compose_log()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "cspkg.log"
    end
    function compose_config()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "config.json"
    end
    function compose_packages()
        return env.user_home() + system.path.separator + ".cspkg" + system.path.separator + "packages.json"
    end
    function compose_cspkg_package()
        return env.covscript_home() + system.path.separator + "imports" + system.path.separator + "cspkg.csp"
    end
    function save()
        utils.save_json(config.content, config.compose_config())
    end
    function create()
        system.path.mkdir_p(config.compose_home())
        if !system.file.exist(config.compose_config())
            config.save()
        end
    end
    function init()
        if !system.path.exist(env.covscript_home() + system.path.separator + "imports")
            system.path.mkdir_p(env.covscript_home() + system.path.separator + "imports")
        end
        if !system.file.exist(config.compose_config())
            config.content = config.default_content
            config.create()
        else
            config.content = utils.open_json(config.compose_config())
        end
    end
end

namespace log_impl
    var log = null
    function open_log()
        if log_impl.log == null
            system.path.mkdir_p(config.compose_home())
            log_impl.log = iostream.fstream(config.compose_log(), iostream.openmode.app)
        end
    end
end

function cspkg_print(msg)
    if !config.cancel_prompt
        system.out.println(msg)
    end
end

function cspkg_log(msg)
    log_impl.open_log()
    system.out.println(msg)
    log_impl.log.println(msg)
end

# Main Function

function cspkg_main()
    var repos = config.content.source.split({';'})
    var target_repo = null
    foreach source_url in repos
        var url_info = utils.parse_url(source_url)
        if url_info == null
            cspkg_log("cspkg: broken source url: \"" + source_url + "\"")
            continue
        end
        cspkg_print("Fetching source from " + url_info.hostname + "...")
        var source_json = utils.get_content(utils.process_url(source_url) + "index.json")
        if source_json == null || source_json.empty()
            cspkg_log("cspkg: failed to fetch index from \"" + source_url + "\"")
            continue
        end
        if utils.parse_json(source_json, new array).to_hash_set().exist("universal")
            target_repo = source_url
            break
        else
            cspkg_log("cspkg: broken source on \"" + url_info.hostname)
            continue
        end        
    end
    if target_repo == null
        cspkg_log("cspkg: fetching source failed.")
        return
    end
    var source_json = utils.get_content(utils.process_url(target_repo) + "index/universal/index.json")
    if source_json == null || source_json.empty() || !utils.parse_json(source_json, new array).to_hash_set().exist("cspkg")
        system.out.println(utils.process_url(target_repo) + "universal/index.json")
        cspkg_log("cspkg: failed to find cspkg from \"" + target_repo + "\"")
        return
    end
    var remote_info = utils.get_content(utils.process_url(target_repo) + "index/universal/cspkg.json")
    if remote_info == null || remote_info.empty()
        cspkg_log("cspkg: broken source on \"" + target_repo + "\"")
        return
    end
    remote_info = utils.parse_json(remote_info, new hash_map)
    var packages = null
    if system.file.exist(config.compose_packages())
        packages = utils.open_json(config.compose_packages())
    else
        packages = new hash_map
    end
    var do_upgrade = false
    if !packages.exist("cspkg")
        if !config.cancel_prompt
            if !system.file.exist(config.compose_cspkg_package())
                system.out.println("Installing cspkg...")
            else
                system.out.println("Fix broken cspkg installation...")
            end
            system.out.println("Do you want to continue?[y/n]")
            if system.console.getch().tolower() != 'y'
                cspkg_log("cspkg: installation canceled.")
                system.exit(0)
            end
        end
        packages["cspkg"] = remote_info
        packages["cspkg"]["FileName"] = "cspkg.csp"
    else
        if remote_info.Version > packages["cspkg"].Version
            do_upgrade = true
            if !config.cancel_prompt
                system.out.println("Detect newer version for cspkg: " + remote_info.Version)
                system.out.println("Do you want to continue?[y/n]")
                if system.console.getch().tolower() != 'y'
                    cspkg_log("cspkg: installation canceled.")
                    return
                end
            end
            packages["cspkg"] = remote_info
            packages["cspkg"]["FileName"] = "cspkg.csp"
        else
            if !system.file.exist(config.compose_cspkg_package())
                cspkg_print("Fix broken cspkg installation...")
            else
                return
            end
        end
    end
    var error_value = utils.get_file(remote_info.Target, config.compose_cspkg_package())
    switch error_value
        case 1
            utils.save_json(packages, config.compose_packages())
            if !do_upgrade
                cspkg_log("cspkg: installation successfully.")
            else
                cspkg_log("cspkg: local installation has been upgraded to " + remote_info.Version)
            end
        end
        case 0
            cspkg_log("cspkg: timeout when download file.")
        end
        case -1
            cspkg_log("cspkg: unable to create file, try run with rights of administrator.")
        end
    end
end

# Processing CLI Args

var cspkg_options = {}
var cspkg_args    = {}
var cmd_args      = context.cmd_args

block
    var idx = 2
    while idx < cmd_args.size
        if cmd_args[idx].find("--", 0) != 0
            cspkg_args.push_back(cmd_args[idx])
        else
            break
        end
        ++idx
    end
    while idx < cmd_args.size
        if cmd_args[idx] == "--yes"
            config.cancel_prompt = true
        else
            cspkg_options.push_back(cmd_args[idx])
        end
        ++idx
    end
end

if cmd_args.size > 1 && cmd_args[1] == "init"
    if !system.file.exist(config.compose_config())
        config.init()
        system.out.print("Configuration file created: ")
    else
        system.out.print("Configuration file existed: ")
    end
    system.out.println(config.compose_config())
    system.exit(0)
end

config.init()
cspkg_main()
var cspkg = context.source_import(config.compose_cspkg_package())
if cspkg == null
    cspkg_log("cspkg: broken cspkg installation.")
    system.exit(0)
end
if cmd_args.size == 1
    cspkg.show_help(null, null)
    system.exit(0)
end
cspkg.config.content = config.content
cspkg.config.default_content = config.default_content
cspkg.config.cancel_prompt = config.cancel_prompt
cspkg.main(cmd_args[1], cspkg_options, cspkg_args)
